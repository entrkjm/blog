[ { "title": "파이썬-구글에서 이미지 검색 및 다운로드 자동화", "url": "/posts/image-cralwer/", "categories": "python, crawling", "tags": "python, selenium", "date": "2022-04-02 04:08:00 +0900", "snippet": "파이썬의 Selenium을 이용해 구글에서 이미지 다운로드를 자동화하기이 프로그램을 만들게 된 계기회사에서 브랜드 3000개에 대한 로고 이미지를 다운로드할 일이 있었습니다. 이 일을 전부 제 손으로 하기에는 너무나 무리라는 생각이 들었고, 구글에 검색해서 이미지를 다운로드할 수 있도록 자동화된 프로그램을(구글링을 통해) Selenium으로 만들었습니다.참고에는 다음 사이트를 활용하였습니다.자세한 내용은 여기를 참조작동 방식이 프로그램은 아래와 같은 순서로 작동합니다.1)검색하고자 하는 키워드의 리스트를 입력 받습니다.2)입력받은 키워드를 구글에 이미지로 검색합니다.3)가장 상단(맨 위 가장 왼쪽)에 노출된 이미지를 클릭하고, 클릭시 PC 기준으로 오른쪽에 뜨는 이미지 중 ‘가장 큰 이미지’를 다운로드 받습니다.4)그 다음은 상단에서 그 다음으로 노출된 이미지(맨 위 왼쪽 두번째 이미지)를 클릭하고, 마찬가지로 ‘가장 큰 이미지’를 다운로드합니다. 키워드 검색시 노출되는 순서에 따라서, 이를 반복하는데요. 이미지를 원하는 숫자만큼 다운로드 받을 수 있습니다.5)다운로드 받은 이미지를, 키워드 이름으로 만든 폴더에 저장합니다.예를 들면 ‘나루토’를 이미지로 검색하고, 검색 결과에서 가장 왼쪽의 이미지를 클릭하면 오른쪽에 검은 배경으로 큰 이미지가 뜹니다. 이 큰 이미지를 다운로드 합니다. 그 다음 검색 결과에서 왼쪽의 이미지를 클릭하고 반복합니다.소스코드소스 코드는 아래와 같습니다. 셀레니움을 설치하고 chromedriver를 다운로드 받는 법에 대해서는 생략하였습니다.from selenium.webdriver.common.keys import Keysfrom selenium import webdriverfrom urllib import requestimport osimport timeimport pandas as pd#폴더를 만들기 위한 메서드def createFolder(directory): try: if not os.path.exists(directory): os.makedirs(directory) except OSError: print (&#39;Error: Creating directory. &#39; + directory)#이미지 다운로드를 위한 메서드def image_downloader(name_list): #name_list: 검색하고자 하는 키워드 목록을 담은 리스트 for i in name_list: name = str(i) directory = #위에서 선언한 name 변수를 활용해서, 파일을 만들 directory를 선언 createFolder(directory) #검색 결과가 나오지 않을 수 있기 때문에, try-error를 활용함 #검색 try: elem = driver.find_element_by_name(&#39;q&#39;) # class=&#39;gLFyf gsfi&#39; elem.clear() elem.send_keys(name) elem.send_keys(Keys.RETURN) time.sleep(1) #검색 결과로 얻은 이미지의 수가 10개가 넘으면 10개만, 10개 미만이면 가능한만큼 다운로드를 시도함 if len(driver.find_elements_by_css_selector(&#39;img.rg_i.Q4LuWd&#39;)) &amp;gt; 10: num = 10 else: num = len(driver.find_elements_by_css_selector(&#39;img.rg_i.Q4LuWd&#39;)) except: continue for j in range(num): #마찬가지로 과정 중 오류가 있을 수 있기 때문에, try-error로 구현 try: driver.find_elements_by_css_selector(&#39;img.rg_i.Q4LuWd&#39;)[j].click() #검색 결과로 나온 이미지를 순서대로 클릭 time.sleep(1) big_image = driver.find_element_by_css_selector(&#39;img.n3VNCb&#39;) #가장 큰 이미지를 선택 bigImage_url = big_image.get_attribute(&#39;src&#39;) request.urlretrieve(bigImage_url, &#39;%s/%s&#39;%(name, name) + str(j+1) + &quot;.jpg&quot;) #이미지를 다운로드해서 폴더에 저장 except: pass driver.close()#image_downloader 메서드 실행name_list = [] #name_list 지정# driver 실행driver = webdriver.Chrome(path) #path에 자신의 chromedriver가 있는 위치를 지정 driver.get(&#39;https://www.google.co.kr/imghp?hl=ko&amp;amp;ogbl&#39;) time.sleep(0.5) #페이지 로딩에 걸리는 시간 image_downloader(name_list)결과‘나루토’를 겸색하여 10개의 이미지를 다운로드 받은 결과는 다음과 같습니다.자세히 보시면 1~10까지 이미지 10개가 생성되어야하는데, 8번과 10번이 빠진채로 다운로드되었음을 확인하실 수 있습니다. 이는 Try-error 처리로 인해서 다운로드 받지 못한 이미지가 있기 때문입니다.실제 검색결과 이미지와 비교하시면, 검색 결과 내에서 그럭저럭 잘 다운로드된 것을 확인하실 수 있습니다.앞서 언급드렸듯이, 저같은 경우는 브랜드 3000개의 로고를 검색해야했기에, 검색 조건에 브랜드 이름 + 로고를 넣어서 검색을 했는데요. 3000개를 10개씩 다운로드 받다보니까 시간이 정말 오래걸리기도 했고, 그냥 검색 결과 이미지를 가져오는 것이다보니, 로고가 아닌 경우가 있더라구요. 그러면…로고인지 아닌지 여부를 판별해주는 분류기가 있으면 좋지 않을까? 라는 생각이 들었습니다. 이 분류기에 대해서는 다음에 글을 적고자 합니다." }, { "title": "Python의 jieba를 활용하여 중국어 문장 분석하기", "url": "/posts/jieba-intro/", "categories": "nlp, jieba", "tags": "python, nlp, jieba", "date": "2022-03-07 04:08:00 +0900", "snippet": "파이썬으로 중국어 문서를 분석하기: jieba library 활용jieba란?회사에서 프로젝트를 하면서, 중국어로 된 문서를 분석할 일이 생겼습니다. 그러다보니 중국어 자연어처리 패키지를 구글링하며 찾았는데, 구글에서 검색하니까 찾는 것이 굉장히 힘들었습니다. 기껏 찾아도 결과가 중국어로 나오는터라 이해하기도 어려웠는데요.jieba는 그 중에서 그나마 영어로 된 문서가 있는, 중국어 tokenizer입니다. tokenizer에 대해 간단하게 설명하자면, 우리가 쓰는 단어나 문장을 ‘의미’ 단위로 나눠서 컴퓨터에 입력할 수 있는 형태로 만드는 프로그램이라고 보시면 됩니다.jieba에서는 미리 여러 기능이 갖춰져 있기 때문에, 이를 활용해서 중국어 문서를 분석하는 프로그램을 만들었다. 그 전에 간단한 사용법부터 보겠습니다.자세한 내용은 여기를 참조jieba.cut과 textjieba.cut(sentence, cut_all = False)는 sentence를 input parameter로 넣으면 jieba tokenizer를 활용해 문장을 단어로 나누어주는 method입니다.import jiebaimport jieba.analyseimport jieba.posseg as psegst = &#39;县公安局交巡警大队、治安大队、国保大队, 辖区派出所及县消防救援大队相关负责人陪同检查。&#39;#return type은 generatorcut_1 = jieba.cut(st, cut_all = True)cut_2 = jieba.cut(st, cut_all = False)for i in cut_1: print(&#39;\\&#39;%s\\&#39;&#39;%i, end=&#39; &#39;)print(&#39;\\n&#39;)for j in cut_1: print(&#39;\\&#39;%s\\&#39;&#39;%j, end=&#39; &#39;)결과는 다음과 같습니다. 약간의 차이가 있는게 보이시나요? cut_all을 True로 바꿔주면, tokenizer가 빡세게(?) 쪼갭니다.#Result&#39;县公安局&#39; &#39;交巡警&#39; &#39;大队&#39; &#39;、&#39; &#39;治安&#39; &#39;大队&#39; &#39;、&#39; &#39;国保&#39; &#39;大队&#39; &#39;、&#39; &#39;辖区&#39; &#39;派出所&#39; &#39;及县&#39; &#39;消防&#39; &#39;救援&#39; &#39;大队&#39; &#39;相关&#39; &#39;负责人&#39; &#39;陪同&#39; &#39;检查&#39; &#39;。&#39; &#39;县公安局&#39; &#39;公安&#39; &#39;公安局&#39; &#39;交巡警&#39; &#39;巡警&#39; &#39;大队&#39; &#39;、&#39; &#39;治安&#39; &#39;大队&#39; &#39;、&#39; &#39;国&#39; &#39;保&#39; &#39;大队&#39; &#39;、&#39; &#39;辖区&#39; &#39;派出&#39; &#39;派出所&#39; &#39;所及&#39; &#39;县&#39; &#39;消防&#39; &#39;救援&#39; &#39;大队&#39; &#39;相关&#39; &#39;负责&#39; &#39;负责人&#39; &#39;责人&#39; &#39;陪同&#39; &#39;检查&#39; &#39;。&#39;jieba_cut의 경우 반환형이 ‘generator’이기 때문에, list를 사용하는 것이 편할 수 있습니다. 그럴 때는 jieba_lcut을 사용하면 됩니다.jieba_cut 외에도 jieba에는 각기 다른 알고리즘을 활용한 tokenizer나 text-extract method가 있는데요. pseg.cut의 경우 jieba_cut과 마찬가지로 동작하지만, 반환형이 (단어, 품사)의 꼴인 tuple을 원소로 갖는 ‘list’여서, 단어만 추출하려면 추가적인 작업이 필요합니다.여기서는 jieba.analyse.extract_tags를 한 번 사용하겠습니다. 이 method는 TF-IDF 알고리즘을 사용하는데요. 이 알고리즘은 전체 문서에서 너무 많이 등장하는 단어는 별 의미가 없다고 간주하여 가중치를 낮추는 방식입니다. 예를 들어 영어의 ‘the’ 같은 단어는 TF-IDF 알고리즘 스코어가 낮게 되겠습니다.그런데 TF-IDF를 제대로 사용하려면, 분석하고자 하는 문서의 각 키워드에 대해서 TF-IDF 스코어를 먼저 구해야하는데요. jieba에서는 사전에 구현된 기본 dictionary와 IDF score가 준비된 상태입니다. 여기서 jieba.analyse.set_ idf_ path(file_ name) method를 활용하면, 제가 따로 만든 custom corpus에 대해서 IDF 스코어를 구하고, 그것을 바탕으로 TF-IDF를 계산할 수 있습니다. 마찬가지로 링크1, 링크2를 참조하시면 되겠습니다.지금은 Tutorial이기 때문에 jieba에서 이미 사전에 준비된 기본 값들을 사용해보도록 하겠습니다.words = jieba.analyse.extract_tags(st, topK = 10) # 상위 10개를 추출words#result [&#39;大队&#39;, &#39;国保&#39;, &#39;及县&#39;, &#39;交巡警&#39;, &#39;县公安局&#39;, &#39;消防&#39;, &#39;陪同&#39;, &#39;治安&#39;, &#39;辖区&#39;, &#39;派出所&#39;]Custom-dictionary 활용하기: add_word앞서 jieba에서는 사전에 준비된 dictionary와 사전에 학습된 문서 데이터를 바탕으로 한 parameter 값을 갖고 있다고 말씀드렸습니다.여기에 제가 원하는 다른 단어를 추가-제거하는 것도 가능합니다.이를테면, 위의 예시를 활용한 아래의 코드에서는 ‘县公安局’ 이 단어가 추가됐다가 빠진 것을 확인하실 수 있습니다.st = &#39;县公安局交巡警大队、治安大队、国保大队、辖区派出所及县消防救援大队相关负责人陪同检查。&#39;jieba.del_word(&#39;县公安局&#39;)cut1 = jieba.lcut(st, cut_all = False)print(cut1)jieba.add_word(&#39;县公安局&#39;)#jieba.add_word(word, freq=None, tag=None)cut2 = jieba.lcut(st, cut_all = False)print(cut2)#result[&#39;县&#39;, &#39;公安局&#39;, &#39;交巡警&#39;, &#39;大队&#39;, &#39;、&#39;, &#39;治安&#39;, &#39;大队&#39;, &#39;、&#39;, &#39;国保&#39;, &#39;大队&#39;, &#39;、&#39;, &#39;辖区&#39;, &#39;派出所&#39;, &#39;及县&#39;, &#39;消防&#39;, &#39;救援&#39;, &#39;大队&#39;, &#39;相关&#39;, &#39;负责人&#39;, &#39;陪同&#39;, &#39;检查&#39;, &#39;。&#39;] [&#39;县公安局&#39;, &#39;交巡警&#39;, &#39;大队&#39;, &#39;、&#39;, &#39;治安&#39;, &#39;大队&#39;, &#39;、&#39;, &#39;国保&#39;, &#39;大队&#39;, &#39;、&#39;, &#39;辖区&#39;, &#39;派出所&#39;, &#39;及县&#39;, &#39;消防&#39;, &#39;救援&#39;, &#39;大队&#39;, &#39;相关&#39;, &#39;负责人&#39;, &#39;陪同&#39;, &#39;检查&#39;, &#39;。&#39;]아예 텍스트 파일로부터 User_custom_dictionary를 load하는 것도 가능한데요.jieba.load_userdict(file_path) #file_path에 txt파일 입력이때 텍스트 파일의 형식은 다음과 같아야 합니다단어(띄어쓰기)빈도(띄어쓰기)품사(\\n)단어(띄어쓰기)....이 때 빈도나 품사는 꼭 필수가 아니며, 빈도의 경우 예측기의 성능에 영향을 미치는 관계로 suggest_freq()라는 method를 이용해 구한 freq를 넣어주는 것도 가능합니다." }, { "title": "삽질에 삽질을 거듭하고 깃허브 블로그 만들기", "url": "/posts/github-blog/", "categories": "github, blog", "tags": "github, blog, jekyll", "date": "2022-03-04 04:08:00 +0900", "snippet": "Github로 블로그 만들기네이버 블로그, 티스토리, 브런치…나는 여러 플랫폼에 글을 써왔으면서도 내가 쓰는 글이 어떤 절차로 어떻게 올라가는지, 어디에 저장되는지, 사람들은 어떻게 내 글을 볼 수 있는지 잘 몰랐었다. 네이버나 티스토리에서 지원하는 에디터는, 굳이 내가 글을 쓰고 편집을 어렵게 하지 않아도 예쁜 형태의 포스트로 만들어주었으며, 네이버 등 회사의 서버는 나의 글을 저장해서 편히 누구든 요청만 하면 접근할 수 있도록 도와주었다.그렇지만 웹 사이트의 호스팅 원리에 대해서 간단하게 알고나니, 그동안 내가 얼마나 쉽게쉽게 살았는지를 실감한다. 도메인 구매도, 호스팅도 모두 돈이 드는 일이고 간단한 웹페이지를 만드는 일조차 나에겐 쉽지 않다. 다른 사람이 내 홈페이지를 보는데에는 그 전에는 몰랐던 복잡한 절차가 숨어있었던 것이다.그래서 깃허브가 제공해주는 호스팅 서버를 받고, 동시에 Jekyll이라는 테마를 활용하여 블로그를 만들어보면서, 이를 간단히 경험해보기로 했다. 중간에 삽질이 굉장히 많아 이틀을 꼬박 사용했지만, 만들기 전에 반드시 알아두어야할 핵심 포인트만 짚으면 다음부터는 어렵지 않을 것으로 보인다.블로그 만들기 전 숙지해야할 점우선 반드시 숙지해야할 포인트는 다음과 같다. 개발을 하며 깃허브에 코드를 올리기 전, 우리는 로컬 저장소에서 작업을 한다. 깃허브 블로그를 만들기 위한 Template은 Jekyll이라는 라이브러리로 이루어져 있으며, 이는 Ruby라는 언어로 작성되어있다.(사실 Ruby를 자세히 알 필요는 없다.)블로그 만들기 절차이 두 포인트를 숙지한다면, 우리의 블로그 만들기 절차는 반드시 다음을 따라야한다. 내가 사용하고자 하는 Jekyll Template 파일들을 로컬 컴퓨터에 옮긴다(깃허브로 Fork하든, Install을 하든…) Jekyll Template을 활용하여 자신에게 맞게 Customize 한 다음에, 이를 Github이 호스팅할 수 있는 형식에 맞추어 Github 저장소에 Pull한다. 자신의 Github 저장소에서 호스팅 절차를 밟는다.발생하는 문제들문제는 이 3단계 스텝 사이사이에서 발생한다.1)에서: 일단 내가 사용하고자 하는 테마는 chirpy이었는데, 이 테마를 그냥 다운 받아서 설치하면 높은 확률로, 2)에서 오류를 낳는다.그렇기 때문에 제작자분이 Github에 만들어 두신 Starter 템플릿을 활용하여 내 Repository를 만들고, 그걸 내 로컬 저장소로 fork해오는 방식이 먹혔다. (Starter 템플릿 외에, 저 개발자분이 만드신 다른 Repository는 뭔가 이슈가 있어서 내 로컬 저장소로 clone해도 잘 작동하지 않는 것 같다.)2)도 문제다. Jekyll Template를 수정하기 위해서는 Template에 따라 다르지만, Ruby를 설치하고 Bundler와 Jekyll이라는 라이브러리를 주로 활용해야하며, 이 외에도 다양한 Plug-in들이 들어간다. 근데 이 Plug-in들도 각기 버전이 있어서, Ruby 버전이나 Bundler, Jekyll 버전과 계속 충돌할 수가 있다. 이렇게 충돌하게 되는 경우 아예 Template를 수정하기가 어렵다.왜냐면 내가 Github로 호스팅하기 전에 로컬에서 이런저런 테스트도 하고, 커스터마이징도 해야하는데 그 절차를 밟기가 너무 어려워지기 때문이다. Template를 만드신 제작자께서 친절히 설명해주시면 좋은데, Jekyll 문서를 참조하라는 식으로 퉁쳐놓은 것들이 많아서 쉽지 않다. (참고로 Ruby에서 설치하는 라이브러리들을 Gem이라고 부르는 듯 한데, 이 수많은 Gem들의 버전을 고려해서 형식을 맞추려면 여간 빡치는 것이 아니다. 기왕이면 Template 만드는 분이 해두신 절차를 따라가는게 제일 좋다.) 간단한 기능만 제공하는 Template면 괜찮은데, 복잡한 기능을 지원하는 경우에는… 이런 일이 빈번히 생길 것이다.3)의 경우 Github에 익숙하다면 별다른 문제가 되지 않을 것이다. 다만, 내가 사용하는 chirpy테마의 경우 로컬에서 수정한 내 블로그를 push하기 전에 사전에 작업해둬야할 것이 있다. 내가 사용하는 테마를 만드신 분께서는, 내가 remote branch에 push할 때에 자동으로 ‘gh-pages’라는 branch를 만들 수 있도록 자동화해두셨고, 나는 이 branch를 호스팅해야한다고 적어두셨다. 링크이 테마에 대한 자세한 지식은 Read.md에는 별로 없고, 데모 사이트의 포스트 중에서 ‘getting-started’라는 설명서가 있는데 이걸 따라하는게 최선이다. 쥐엔장… 너무 불친절해서 어떤게 설명서인지조차 찾아야하는게 개빡친다.정리 및 여담여튼 1) 업데이트가 잘 돼서 충돌하지 않을 Template 파일들을 내 로컬 저장소로(절차에 맞게) 잘 가져오고 2) Jekyll에서 정한 룰에 맞게 ‘_config.yml’ 파일을 잘 수정해주면서 Custominzing하고, 3) Github에 잘 호환되도록 제작자님이 정한 룰에 맞게 잘 호스팅하는 것이 최선이다. 이게 블로그 만들기의 전부이고 핵심이다.여담1) 그렇다면 블로그에 글은 어떻게 쓸까? 우선 로컬 저장소에서 Jekyll의 룰에 맞게 md 파일을 만들고, 그걸 post 폴더에 두면 된다. 그리고 이를 remote에 push하면 내 로컬 저장소에서 변경된 사항이 remote에 반영되고, 반영된 내용이 호스팅되는 형식이다. 캬. 평상시 네이버 블로그에 글쓰는 것을 생각하면…이와 반대일 것이다.에디터가 삽입된 네이버의 웹페이지에 내가 글을 쓰고, 그 글이 네이버의 데이터베이스에 저장돼서 누군가가 내 블로그에 방문해서 글을 볼 때마다 호출될 수 있도록 연결이 유지되어 있어야 할 것이다. Github 블로그에서는 내가 내 데이터베이스를 수정해서 글을 쓰고 그 글이 remote를 통해 반영되면 github에서 이에 접근할 수 있도록 연결해준다.블로그에 글을 쓸 때는 GIt의 버전 관리를 이용하면 좋다. 우선 글을 써서 파일을 업데이트할 Branch를 하나 정해놓고, 그걸로 push한 다음에 잘 되면 ‘master’ branch에도 merge하거나 pull 받거나 하는 방식을 쓴다. 이러면 오류가 나도 master branch는 이전 버전에 있기 때문에, 여기서부터 다시 시작하기 편하다.여담2) Jekyll은 꽤 좋은 것 같다. 직관적으로 잘 이해된다. 단순한 기능만 잘 익힌다면 그리 어려운 것은 없는 듯 하다." } ]
